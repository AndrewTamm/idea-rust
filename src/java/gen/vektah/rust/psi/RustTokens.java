// This is a generated file. Not intended for manual editing.
package vektah.rust.psi;

import com.intellij.psi.tree.IElementType;
import com.intellij.psi.PsiElement;
import com.intellij.lang.ASTNode;
import vektah.rust.psi.impl.*;

public interface RustTokens {

  IElementType ATTRIBUTE = new RustTokenType("ATTRIBUTE");
  IElementType ATTRIBUTE_ARG = new RustTokenType("ATTRIBUTE_ARG");
  IElementType BLOCK_FOR = new RustTokenType("BLOCK_FOR");
  IElementType BLOCK_IF = new RustTokenType("BLOCK_IF");
  IElementType BLOCK_LOOP = new RustTokenType("BLOCK_LOOP");
  IElementType BLOCK_WHILE = new RustTokenType("BLOCK_WHILE");
  IElementType CALL_PARAMS = new RustTokenType("CALL_PARAMS");
  IElementType EXPR = new RustTokenType("EXPR");
  IElementType EXPRESSION = new RustTokenType("EXPRESSION");
  IElementType EXPR_ASSIGN = new RustTokenType("EXPR_ASSIGN");
  IElementType EXPR_BITWISE_AND = new RustTokenType("EXPR_BITWISE_AND");
  IElementType EXPR_BITWISE_OR = new RustTokenType("EXPR_BITWISE_OR");
  IElementType EXPR_BITWISE_XOR = new RustTokenType("EXPR_BITWISE_XOR");
  IElementType EXPR_BLOCK = new RustTokenType("EXPR_BLOCK");
  IElementType EXPR_BORROW = new RustTokenType("EXPR_BORROW");
  IElementType EXPR_BOX = new RustTokenType("EXPR_BOX");
  IElementType EXPR_BREAK = new RustTokenType("EXPR_BREAK");
  IElementType EXPR_CALL = new RustTokenType("EXPR_CALL");
  IElementType EXPR_CONTINUE = new RustTokenType("EXPR_CONTINUE");
  IElementType EXPR_DEREF = new RustTokenType("EXPR_DEREF");
  IElementType EXPR_DIVIDE = new RustTokenType("EXPR_DIVIDE");
  IElementType EXPR_EQUAL_TO = new RustTokenType("EXPR_EQUAL_TO");
  IElementType EXPR_FIELD = new RustTokenType("EXPR_FIELD");
  IElementType EXPR_GREATER_OR_EQUAL = new RustTokenType("EXPR_GREATER_OR_EQUAL");
  IElementType EXPR_GREATER_THAN = new RustTokenType("EXPR_GREATER_THAN");
  IElementType EXPR_LEFT_SHIFT = new RustTokenType("EXPR_LEFT_SHIFT");
  IElementType EXPR_LESS_OR_EQUAL = new RustTokenType("EXPR_LESS_OR_EQUAL");
  IElementType EXPR_LESS_THAN = new RustTokenType("EXPR_LESS_THAN");
  IElementType EXPR_LOGICAL_AND = new RustTokenType("EXPR_LOGICAL_AND");
  IElementType EXPR_LOGICAL_OR = new RustTokenType("EXPR_LOGICAL_OR");
  IElementType EXPR_MINUS = new RustTokenType("EXPR_MINUS");
  IElementType EXPR_MULTIPLY = new RustTokenType("EXPR_MULTIPLY");
  IElementType EXPR_NOT_EQUAL_TO = new RustTokenType("EXPR_NOT_EQUAL_TO");
  IElementType EXPR_PAREN = new RustTokenType("EXPR_PAREN");
  IElementType EXPR_PLUS = new RustTokenType("EXPR_PLUS");
  IElementType EXPR_RIGHT_SHIFT = new RustTokenType("EXPR_RIGHT_SHIFT");
  IElementType EXPR_TUPLE_BODY = new RustTokenType("EXPR_TUPLE_BODY");
  IElementType EXPR_UNARY_MINUS = new RustTokenType("EXPR_UNARY_MINUS");
  IElementType EXPR_UNARY_NOT = new RustTokenType("EXPR_UNARY_NOT");
  IElementType EXPR_UNARY_PLUS = new RustTokenType("EXPR_UNARY_PLUS");
  IElementType EXPR_VALUE = new RustTokenType("EXPR_VALUE");
  IElementType EXTERN = new RustTokenType("EXTERN");
  IElementType EXTERN_CRATE = new RustTokenType("EXTERN_CRATE");
  IElementType EXTERN_FUNCTION = new RustTokenType("EXTERN_FUNCTION");
  IElementType EXTERN_STRING = new RustTokenType("EXTERN_STRING");
  IElementType FUNCTION = new RustTokenType("FUNCTION");
  IElementType FUNCTION_DECLARATION = new RustTokenType("FUNCTION_DECLARATION");
  IElementType FUNCTION_TYPE = new RustTokenType("FUNCTION_TYPE");
  IElementType GENERIC = new RustTokenType("GENERIC");
  IElementType GENERIC_PARAMS = new RustTokenType("GENERIC_PARAMS");
  IElementType LET = new RustTokenType("LET");
  IElementType LIFETIME = new RustTokenType("LIFETIME");
  IElementType PATH = new RustTokenType("PATH");
  IElementType REF = new RustTokenType("REF");
  IElementType REGION_BOUND = new RustTokenType("REGION_BOUND");
  IElementType SELF_ARG = new RustTokenType("SELF_ARG");
  IElementType STANDARD_ARG = new RustTokenType("STANDARD_ARG");
  IElementType STATEMENT_BLOCK = new RustTokenType("STATEMENT_BLOCK");
  IElementType STATEMENT_BLOCK_INTERNAL = new RustTokenType("STATEMENT_BLOCK_INTERNAL");
  IElementType STATIC_EXPRESSION = new RustTokenType("STATIC_EXPRESSION");
  IElementType STATIC_EXPRESSION_GROUP = new RustTokenType("STATIC_EXPRESSION_GROUP");
  IElementType STRUCT = new RustTokenType("STRUCT");
  IElementType STRUCT_BODY = new RustTokenType("STRUCT_BODY");
  IElementType STRUCT_PROPERTY = new RustTokenType("STRUCT_PROPERTY");
  IElementType TRAIT = new RustTokenType("TRAIT");
  IElementType TRAIT_BOUNDS = new RustTokenType("TRAIT_BOUNDS");
  IElementType TRAIT_FUNCTION_DECLARATION = new RustTokenType("TRAIT_FUNCTION_DECLARATION");
  IElementType TUPLE_ARG = new RustTokenType("TUPLE_ARG");
  IElementType TUPLE_BODY = new RustTokenType("TUPLE_BODY");
  IElementType TYPE_BASIC = new RustTokenType("TYPE_BASIC");
  IElementType TYPE_CLOSURE = new RustTokenType("TYPE_CLOSURE");
  IElementType TYPE_DEFINITION = new RustTokenType("TYPE_DEFINITION");
  IElementType TYPE_NONE = new RustTokenType("TYPE_NONE");
  IElementType TYPE_PROC = new RustTokenType("TYPE_PROC");
  IElementType TYPE_TUPLE = new RustTokenType("TYPE_TUPLE");
  IElementType USE = new RustTokenType("USE");

  IElementType AS = new RustTokenType("AS");
  IElementType ASSIGN = new RustTokenType("=");
  IElementType AT = new RustTokenType("@");
  IElementType BINOP = new RustTokenType("BINOP");
  IElementType BIN_LIT = new RustTokenType("BIN_LIT");
  IElementType BITWISE_AND = new RustTokenType("&");
  IElementType BITWISE_OR = new RustTokenType("|");
  IElementType BITWISE_XOR = new RustTokenType("^");
  IElementType BLOCK_COMMENT = new RustTokenType("BLOCK_COMMENT");
  IElementType BLOCK_DOC_COMMENT = new RustTokenType("BLOCK_DOC_COMMENT");
  IElementType BOX = new RustTokenType("~");
  IElementType CHAR_LIT = new RustTokenType("CHAR_LIT");
  IElementType CLOSE_BRACE = new RustTokenType("}");
  IElementType CLOSE_PAREN = new RustTokenType(")");
  IElementType CLOSE_SQUARE_BRACKET = new RustTokenType("]");
  IElementType COLON = new RustTokenType(":");
  IElementType COMMA = new RustTokenType(",");
  IElementType DEC_LIT = new RustTokenType("DEC_LIT");
  IElementType DIVIDE = new RustTokenType("/");
  IElementType DOLLAR = new RustTokenType("$");
  IElementType DOT = new RustTokenType(".");
  IElementType DOUBLE_COLON = new RustTokenType("::");
  IElementType EQUAL = new RustTokenType("==");
  IElementType FAT_ARROW = new RustTokenType("=>");
  IElementType GREATER_THAN = new RustTokenType(">");
  IElementType GREATER_THAN_OR_EQUAL = new RustTokenType(">=");
  IElementType HASH = new RustTokenType("#");
  IElementType HEX_LIT = new RustTokenType("HEX_LIT");
  IElementType IDENTIFIER = new RustTokenType("IDENTIFIER");
  IElementType KW_AS = new RustTokenType("as");
  IElementType KW_BREAK = new RustTokenType("break");
  IElementType KW_CONTINUE = new RustTokenType("continue");
  IElementType KW_CRATE = new RustTokenType("crate");
  IElementType KW_ELSE = new RustTokenType("else");
  IElementType KW_ENUM = new RustTokenType("enum");
  IElementType KW_EXTERN = new RustTokenType("extern");
  IElementType KW_FALSE = new RustTokenType("false");
  IElementType KW_FN = new RustTokenType("fn");
  IElementType KW_FOR = new RustTokenType("for");
  IElementType KW_IF = new RustTokenType("if");
  IElementType KW_IMPL = new RustTokenType("impl");
  IElementType KW_IN = new RustTokenType("in");
  IElementType KW_LET = new RustTokenType("let");
  IElementType KW_LOOP = new RustTokenType("loop");
  IElementType KW_MATCH = new RustTokenType("match");
  IElementType KW_MOD = new RustTokenType("mod");
  IElementType KW_MUT = new RustTokenType("mut");
  IElementType KW_PRIV = new RustTokenType("priv");
  IElementType KW_PROC = new RustTokenType("proc");
  IElementType KW_PUB = new RustTokenType("pub");
  IElementType KW_REF = new RustTokenType("ref");
  IElementType KW_RETURN = new RustTokenType("return");
  IElementType KW_SELF = new RustTokenType("self");
  IElementType KW_STATIC = new RustTokenType("static");
  IElementType KW_STRUCT = new RustTokenType("struct");
  IElementType KW_SUPER = new RustTokenType("super");
  IElementType KW_TRAIT = new RustTokenType("trait");
  IElementType KW_TRUE = new RustTokenType("true");
  IElementType KW_TYPE = new RustTokenType("type");
  IElementType KW_UNSAFE = new RustTokenType("unsafe");
  IElementType KW_USE = new RustTokenType("use");
  IElementType KW_WHILE = new RustTokenType("while");
  IElementType LESS_THAN = new RustTokenType("<");
  IElementType LESS_THAN_OR_EQUAL = new RustTokenType("<=");
  IElementType LINE_COMMENT = new RustTokenType("LINE_COMMENT");
  IElementType LINE_DOC_COMMENT = new RustTokenType("LINE_DOC_COMMENT");
  IElementType MINUS = new RustTokenType("-");
  IElementType MULTIPLY = new RustTokenType("*");
  IElementType NOT = new RustTokenType("!");
  IElementType NOT_EQUAL = new RustTokenType("!=");
  IElementType OCT_LIT = new RustTokenType("OCT_LIT");
  IElementType OPEN_BRACE = new RustTokenType("{");
  IElementType OPEN_PAREN = new RustTokenType("(");
  IElementType OPEN_SQUARE_BRACKET = new RustTokenType("[");
  IElementType PLUS = new RustTokenType("+");
  IElementType RAW_STRING_LIT = new RustTokenType("RAW_STRING_LIT");
  IElementType REMAINDER = new RustTokenType("%");
  IElementType SEMICOLON = new RustTokenType(";");
  IElementType SINGLE_QUOTE = new RustTokenType("'");
  IElementType STRING_LIT = new RustTokenType("STRING_LIT");
  IElementType THIN_ARROW = new RustTokenType("->");
  IElementType UNOP = new RustTokenType("UNOP");

  class Factory {
    public static PsiElement createElement(ASTNode node) {
      IElementType type = node.getElementType();
       if (type == ATTRIBUTE) {
        return new RustAttributeImpl(node);
      }
      else if (type == ATTRIBUTE_ARG) {
        return new RustAttributeArgImpl(node);
      }
      else if (type == BLOCK_FOR) {
        return new RustBlockForImpl(node);
      }
      else if (type == BLOCK_IF) {
        return new RustBlockIfImpl(node);
      }
      else if (type == BLOCK_LOOP) {
        return new RustBlockLoopImpl(node);
      }
      else if (type == BLOCK_WHILE) {
        return new RustBlockWhileImpl(node);
      }
      else if (type == CALL_PARAMS) {
        return new RustCallParamsImpl(node);
      }
      else if (type == EXPR) {
        return new RustExprImpl(node);
      }
      else if (type == EXPRESSION) {
        return new RustExpressionImpl(node);
      }
      else if (type == EXPR_ASSIGN) {
        return new RustExprAssignImpl(node);
      }
      else if (type == EXPR_BITWISE_AND) {
        return new RustExprBitwiseAndImpl(node);
      }
      else if (type == EXPR_BITWISE_OR) {
        return new RustExprBitwiseOrImpl(node);
      }
      else if (type == EXPR_BITWISE_XOR) {
        return new RustExprBitwiseXorImpl(node);
      }
      else if (type == EXPR_BLOCK) {
        return new RustExprBlockImpl(node);
      }
      else if (type == EXPR_BORROW) {
        return new RustExprBorrowImpl(node);
      }
      else if (type == EXPR_BOX) {
        return new RustExprBoxImpl(node);
      }
      else if (type == EXPR_BREAK) {
        return new RustExprBreakImpl(node);
      }
      else if (type == EXPR_CALL) {
        return new RustExprCallImpl(node);
      }
      else if (type == EXPR_CONTINUE) {
        return new RustExprContinueImpl(node);
      }
      else if (type == EXPR_DEREF) {
        return new RustExprDerefImpl(node);
      }
      else if (type == EXPR_DIVIDE) {
        return new RustExprDivideImpl(node);
      }
      else if (type == EXPR_EQUAL_TO) {
        return new RustExprEqualToImpl(node);
      }
      else if (type == EXPR_FIELD) {
        return new RustExprFieldImpl(node);
      }
      else if (type == EXPR_GREATER_OR_EQUAL) {
        return new RustExprGreaterOrEqualImpl(node);
      }
      else if (type == EXPR_GREATER_THAN) {
        return new RustExprGreaterThanImpl(node);
      }
      else if (type == EXPR_LEFT_SHIFT) {
        return new RustExprLeftShiftImpl(node);
      }
      else if (type == EXPR_LESS_OR_EQUAL) {
        return new RustExprLessOrEqualImpl(node);
      }
      else if (type == EXPR_LESS_THAN) {
        return new RustExprLessThanImpl(node);
      }
      else if (type == EXPR_LOGICAL_AND) {
        return new RustExprLogicalAndImpl(node);
      }
      else if (type == EXPR_LOGICAL_OR) {
        return new RustExprLogicalOrImpl(node);
      }
      else if (type == EXPR_MINUS) {
        return new RustExprMinusImpl(node);
      }
      else if (type == EXPR_MULTIPLY) {
        return new RustExprMultiplyImpl(node);
      }
      else if (type == EXPR_NOT_EQUAL_TO) {
        return new RustExprNotEqualToImpl(node);
      }
      else if (type == EXPR_PAREN) {
        return new RustExprParenImpl(node);
      }
      else if (type == EXPR_PLUS) {
        return new RustExprPlusImpl(node);
      }
      else if (type == EXPR_RIGHT_SHIFT) {
        return new RustExprRightShiftImpl(node);
      }
      else if (type == EXPR_TUPLE_BODY) {
        return new RustExprTupleBodyImpl(node);
      }
      else if (type == EXPR_UNARY_MINUS) {
        return new RustExprUnaryMinusImpl(node);
      }
      else if (type == EXPR_UNARY_NOT) {
        return new RustExprUnaryNotImpl(node);
      }
      else if (type == EXPR_UNARY_PLUS) {
        return new RustExprUnaryPlusImpl(node);
      }
      else if (type == EXPR_VALUE) {
        return new RustExprValueImpl(node);
      }
      else if (type == EXTERN) {
        return new RustExternImpl(node);
      }
      else if (type == EXTERN_CRATE) {
        return new RustExternCrateImpl(node);
      }
      else if (type == EXTERN_FUNCTION) {
        return new RustExternFunctionImpl(node);
      }
      else if (type == EXTERN_STRING) {
        return new RustExternStringImpl(node);
      }
      else if (type == FUNCTION) {
        return new RustFunctionImpl(node);
      }
      else if (type == FUNCTION_DECLARATION) {
        return new RustFunctionDeclarationImpl(node);
      }
      else if (type == FUNCTION_TYPE) {
        return new RustFunctionTypeImpl(node);
      }
      else if (type == GENERIC) {
        return new RustGenericImpl(node);
      }
      else if (type == GENERIC_PARAMS) {
        return new RustGenericParamsImpl(node);
      }
      else if (type == LET) {
        return new RustLetImpl(node);
      }
      else if (type == LIFETIME) {
        return new RustLifetimeImpl(node);
      }
      else if (type == PATH) {
        return new RustPathImpl(node);
      }
      else if (type == REF) {
        return new RustRefImpl(node);
      }
      else if (type == REGION_BOUND) {
        return new RustRegionBoundImpl(node);
      }
      else if (type == SELF_ARG) {
        return new RustSelfArgImpl(node);
      }
      else if (type == STANDARD_ARG) {
        return new RustStandardArgImpl(node);
      }
      else if (type == STATEMENT_BLOCK) {
        return new RustStatementBlockImpl(node);
      }
      else if (type == STATEMENT_BLOCK_INTERNAL) {
        return new RustStatementBlockInternalImpl(node);
      }
      else if (type == STATIC_EXPRESSION) {
        return new RustStaticExpressionImpl(node);
      }
      else if (type == STATIC_EXPRESSION_GROUP) {
        return new RustStaticExpressionGroupImpl(node);
      }
      else if (type == STRUCT) {
        return new RustStructImpl(node);
      }
      else if (type == STRUCT_BODY) {
        return new RustStructBodyImpl(node);
      }
      else if (type == STRUCT_PROPERTY) {
        return new RustStructPropertyImpl(node);
      }
      else if (type == TRAIT) {
        return new RustTraitImpl(node);
      }
      else if (type == TRAIT_BOUNDS) {
        return new RustTraitBoundsImpl(node);
      }
      else if (type == TRAIT_FUNCTION_DECLARATION) {
        return new RustTraitFunctionDeclarationImpl(node);
      }
      else if (type == TUPLE_ARG) {
        return new RustTupleArgImpl(node);
      }
      else if (type == TUPLE_BODY) {
        return new RustTupleBodyImpl(node);
      }
      else if (type == TYPE_BASIC) {
        return new RustTypeBasicImpl(node);
      }
      else if (type == TYPE_CLOSURE) {
        return new RustTypeClosureImpl(node);
      }
      else if (type == TYPE_DEFINITION) {
        return new RustTypeDefinitionImpl(node);
      }
      else if (type == TYPE_NONE) {
        return new RustTypeNoneImpl(node);
      }
      else if (type == TYPE_PROC) {
        return new RustTypeProcImpl(node);
      }
      else if (type == TYPE_TUPLE) {
        return new RustTypeTupleImpl(node);
      }
      else if (type == USE) {
        return new RustUseImpl(node);
      }
      throw new AssertionError("Unknown element type: " + type);
    }
  }
}
