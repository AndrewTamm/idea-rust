{
	parserClass="vektah.rust.RustParser"

	psiClassPrefix="Rust"
	psiImplClassSuffix="Impl"
	psiPackage="vektah.rust.psi"
	psiImplPackage="vektah.rust.psi.impl"

	elementTypeHolderClass="vektah.rust.psi.RustTokens"
	elementTypeClass="vektah.rust.psi.RustTokenType"
	tokenTypeClass="vektah.rust.psi.RustTokenType"

	tokenTypeClass("keyword")="vektah.rust.psi.RustKeywordTokenType"

	tokens = [
		KW_AS = "as"
		KW_BREAK = "break"
		KW_CRATE = "crate"
		KW_ELSE = "else"
		KW_ENUM = "enum"
		KW_EXTERN = "extern"
		KW_FALSE = "false"
		KW_FN = "fn"
		KW_FOR = "for"
		KW_IF = "if"
		KW_IMPL = "impl"
		KW_IN = "in"
		KW_LET = "let"
		KW_LOOP = "loop"
		KW_MATCH = "match"
		KW_MOD = "mod"
		KW_MUT = "mut"
		KW_PRIV = "priv"
		KW_PROC = "proc"
		KW_PUB = "pub"
		KW_REF = "ref"
		KW_RETURN = "return"
		KW_SELF = "self"
		KW_STATIC = "static"
		KW_STRUCT = "struct"
		KW_SUPER = "super"
		KW_TRUE = "true"
		KW_TRAIT = "trait"
		KW_TYPE = "type"
		KW_UNSAFE = "unsafe"
		KW_USE = "use"
		KW_WHILE = "while"

		FAT_ARROW = "=>"
		THIN_ARROW = "->"
		DOT = "."

		BITWISE_AND = "&"
		BITWISE_OR = "|"
		BITWISE_XOR = "^"

		DOUBLE_COLON = "::"
		COLON = ":"

		PLUS = "+"
		MINUS = "-"
		MULTIPLY = "*"
		DIVIDE = "/"
		REMAINDER = "%"

		EQUAL = "=="
		ASSIGN = "="
		NOT_EQUAL = "!="
		LESS_THAN_OR_EQUAL = "<="
		LESS_THAN = "<"
		GREATER_THAN_OR_EQUAL = ">="
		GREATER_THAN = ">"

		NOT = "!"
		BOX = "~"
		AT = "@"
		SINGLE_QUOTE = "'"
		DOLLAR = "$"

		HASH = "#"
		OPEN_SQUARE_BRACKET = "["
		CLOSE_SQUARE_BRACKET = "]"
		OPEN_PAREN = "("
		CLOSE_PAREN = ")"
		OPEN_BRACE = "{"
		CLOSE_BRACE = "}"
		COMMA = ","
		SEMICOLON = ";"
	]
}

simpleFile ::= ( use
	| function
	| struct
	| trait
	| extern
	| token
)*

// AGGREGATE TYPES
private numeric_literal ::= BIN_LIT | OCT_LIT | HEX_LIT | DEC_LIT;

// Generic recovery predicates
private not_close_brace ::= !('}')
private not_semicolon ::= !(SEMICOLON)


// TYPES
path ::= '::'? IDENTIFIER ('::' IDENTIFIER)* '::' generic
private type ::= type_basic | type_tuple | type_closure | function_type | type_proc | type_none

type_basic ::= ( ref 'mut'? | lifetime | '*'+)? 'mut'? ('~' | '@' | '$')? ( type_path | '[' type [',' '.' '.' (IDENTIFIER | numeric_literal)] ']' )

type_tuple ::= '(' type (',' type)* ')'
function_type ::= 'fn' '(' type_closure_args ')' ['->' return_type]
type_closure ::= '|' type_closure_args '|' ['->' return_type]
type_proc ::= 'proc' '(' type_closure_args ')' ['->' return_type]
type_none ::= '*'? '(' ')'
private type_closure_args ::=  [ type_closure_arg ( ',' type_closure_arg)* ]
private type_closure_arg ::= standard_arg | type_basic

private type_path ::= '::'? IDENTIFIER ('::' IDENTIFIER)* generic?
ref ::= '&'+ lifetime?
lifetime ::= "'" (IDENTIFIER | 'static')


// GENERIC PARAM LIST eg function<A>(...)
generic_params ::= '<' generic_param (',' generic_param)* '>'
private generic_param ::= lifetime | IDENTIFIER [(':' | '=') type ('+' type)* ]


// GENERIC TYPES eg Option<Foo>
generic ::= generic_internal '>'
private generic_internal ::= '<' (generic_without_lifetime | generic_with_lifetime)  {pin=1 recoverWhile="generic_recover"}
private generic_with_lifetime ::= lifetime (',' lifetime)* (',' type)*
private generic_without_lifetime ::= type ( ',' type)*
private generic_recover ::= !('>')


// USE
use ::= use_internal ';'
private use_internal ::= ['pub'] 'use' use_part ('::' use_part)* use_glob? ['=' path] {pin=2 recoverWhile="not_semicolon"}
private use_glob ::= '::' ('*' | '{' IDENTIFIER ( ',' IDENTIFIER )* '}')
private use_part ::= (IDENTIFIER | 'super' | 'self')


// FUNCTIONS
function ::= function_declaration statement_block
function_declaration ::= ['pub'] 'fn' IDENTIFIER generic_params? '(' ( arg (',' arg)* )? ')' ['->' return_type] {pin=2 recoverWhile="function_recover" }
private return_type ::= type | '!'
private function_recover ::= !('{'|';')

private arg ::= self_arg | standard_arg | tuple_arg

standard_arg ::= arg_name [':' type ]
tuple_arg ::= '(' arg_name (',' arg_name)* ')' [':' type ]
self_arg ::= ref? 'mut'? '~'? 'self'
private arg_name ::= ref? 'mut'? IDENTIFIER

statement_block ::= '{' statement* '}'
statement ::= statement_block | function | use | (simple_token|literal|comment|symbol|operators|keyword|IDENTIFIER|OPEN_SQUARE_BRACKET|CLOSE_SQUARE_BRACKET|OPEN_PAREN|CLOSE_PAREN)


// STRUCTS
struct ::= struct_internal '}'
private struct_internal ::= ['pub'] 'struct' IDENTIFIER generic_params? '{' [struct_property (',' struct_property)* ] ','? {pin=2 recoverWhile="not_close_brace"}
struct_property ::= ['priv' | 'pub'] standard_arg


// TRAITS
trait ::= trait_internal '}'
private trait_internal ::= ['priv' | 'pub'] 'trait' IDENTIFIER generic_params? [':' type] '{' (function_declaration ';')* {pin=2 recoverWhile="not_close_brace"}

// EXTERNALS
extern ::= extern_internal '}'
extern_internal ::= 'extern' '{' (function_declaration ';')* {pin = 2 recoverWhile="not_close_brace"}

private token ::= (simple_token|literal|comment|symbol|brackets|operators|keyword|IDENTIFIER)
private keyword ::= (KW_AS|KW_BREAK|KW_CRATE|KW_ELSE|KW_ENUM|KW_EXTERN|KW_FALSE|KW_FOR|KW_IF|KW_IMPL|KW_IN|KW_LET|KW_LOOP|KW_MATCH|KW_MOD|KW_MUT|KW_PRIV|KW_PROC|KW_PUB|KW_REF|KW_RETURN|KW_SELF|KW_STATIC|KW_SUPER|KW_TRUE|KW_TYPE|KW_UNSAFE|KW_WHILE)
private simple_token ::= (UNOP|BINOP)
private comment ::= (BLOCK_COMMENT|LINE_COMMENT)
private literal ::= (STRING_LIT|RAW_STRING_LIT|CHAR_LIT|NUM_LIT|DEC_LIT|BIN_LIT|OCT_LIT|HEX_LIT)
private brackets ::= (OPEN_SQUARE_BRACKET|CLOSE_SQUARE_BRACKET|OPEN_PAREN|CLOSE_PAREN|OPEN_BRACE|CLOSE_BRACE)
private symbol ::= (HASH|COMMA|SEMICOLON|DOUBLE_COLON|THIN_ARROW|FAT_ARROW|DOT|AT|SINGLE_QUOTE|DOLLAR|':')
private operators ::= (arithmetic_operators|bitwise_operators|comparison_operators|unary_operators|AS|ASSIGN)
private arithmetic_operators ::= (PLUS|MINUS|MULTIPLY|DIVIDE|REMAINDER|)
private bitwise_operators ::= (BITWISE_AND|BITWISE_OR|BITWISE_XOR)
private unary_operators ::= (NOT|BOX)
private comparison_operators ::= (EQUAL|GREATER_THAN|LESS_THAN|NOT_EQUAL|GREATER_THAN_OR_EQUAL|LESS_THAN_OR_EQUAL)
