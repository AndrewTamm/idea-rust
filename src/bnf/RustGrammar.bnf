{
	parserClass="vektah.rust.RustParser"

	psiClassPrefix="Rust"
	psiImplClassSuffix="Impl"
	psiPackage="vektah.rust.psi"
	psiImplPackage="vektah.rust.psi.impl"

	elementTypeHolderClass="vektah.rust.psi.RustTokens"
	elementTypeClass="vektah.rust.psi.RustTokenType"
	tokenTypeClass="vektah.rust.psi.RustTokenType"

	tokenTypeClass("keyword")="vektah.rust.psi.RustKeywordTokenType"

	extends("expr_.*")=expr
	extends("block_.*")=expr_block
	extends(".*_match_pattern")=match_pattern
	consumeTokenMethod("expr_.*|expr")="consumeTokenFast"

	tokens = [
		KW_AS = "as"
		KW_BREAK = "break"
		KW_CRATE = "crate"
		KW_ELSE = "else"
		KW_ENUM = "enum"
		KW_EXTERN = "extern"
		KW_FALSE = "false"
		KW_FN = "fn"
		KW_FOR = "for"
		KW_IF = "if"
		KW_IMPL = "impl"
		KW_IN = "in"
		KW_LET = "let"
		KW_LOOP = "loop"
		KW_MATCH = "match"
		KW_MOD = "mod"
		KW_MUT = "mut"
		KW_PRIV = "priv"
		KW_PROC = "proc"
		KW_PUB = "pub"
		KW_REF = "ref"
		KW_RETURN = "return"
		KW_SELF = "self"
		KW_STATIC = "static"
		KW_STRUCT = "struct"
		KW_SUPER = "super"
		KW_TRUE = "true"
		KW_TRAIT = "trait"
		KW_TYPE = "type"
		KW_UNSAFE = "unsafe"
		KW_USE = "use"
		KW_WHILE = "while"
		KW_CONTINUE = "continue"

		FAT_ARROW = "=>"
		THIN_ARROW = "->"
		DOT = "."

		BITWISE_AND = "&"
		BITWISE_OR = "|"
		BITWISE_XOR = "^"

		DOUBLE_COLON = "::"
		COLON = ":"

		PLUS = "+"
		MINUS = "-"
		MULTIPLY = "*"
		DIVIDE = "/"
		REMAINDER = "%"

		EQUAL = "=="
		ASSIGN = "="
		NOT_EQUAL = "!="
		LESS_THAN_OR_EQUAL = "<="
		LESS_THAN = "<"
		GREATER_THAN_OR_EQUAL = ">="
		GREATER_THAN = ">"

		NOT = "!"
		BOX = "~"
		AT = "@"
		SINGLE_QUOTE = "'"
		DOLLAR = "$"

		HASH = "#"
		OPEN_SQUARE_BRACKET = "["
		CLOSE_SQUARE_BRACKET = "]"
		OPEN_PAREN = "("
		CLOSE_PAREN = ")"
		OPEN_BRACE = "{"
		CLOSE_BRACE = "}"
		COMMA = ","
		SEMICOLON = ";"
	]
}

simpleFile ::= ( use
	| function
	| struct
	| trait
	| extern
	| type_definition
	| attribute
	| token
)*

// AGGREGATE TYPES
private numeric_literal ::= BIN_LIT | OCT_LIT | HEX_LIT | DEC_LIT
private string_literal ::= STRING_LIT | RAW_STRING_LIT | CHAR_LIT
private literal ::= string_literal | numeric_literal | 'true' | 'false' | 'self' | '(' ')'
private binary_operator ::= '/' | '*' | '+' | '-' | '<' '<' | '>' '>'

// Generic recovery predicates
private not_close_brace ::= !('}')
private not_semicolon ::= !(';')
private not_close_parenthesis ::= !(')')
private not_semicolon_or_open_brace ::= !('{' | ';')

// Cut back expressions usable in static contexts
static_expression ::= (IDENTIFIER | literal | static_expression_group) (binary_operator (IDENTIFIER | literal | static_expression_group))*
static_expression_group ::= '(' static_expression ')'


// EXPRESSIONS! - this is based heavily https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md
// These are in increasing order of precedence  (opposite of rust manual)
expr ::= expr_block
	| expr_call
	| builtin_expression_group
	| assign_group
	| expr_logical_or
	| expr_logical_and
	| equals_group
	| comparison_group
	| expr_bitwise_or
	| expr_bitwise_xor
	| expr_bitwise_and
	| shift_group
	| add_group
	| expr_as
	| mul_group
	| unary_group
	| expr_field
	| closure_group
	| primary_group

expr_as ::= expr 'as' type

expr_bitwise_and ::= expr '&' expr
expr_bitwise_xor ::= expr '^' expr
expr_bitwise_or ::= expr '|' expr

private assign_group ::= expr_assign
	| expr_assign_increment
	| expr_assign_decrement
	| expr_assign_multiply
	| expr_assign_divide
	| expr_assign_modulo
	| expr_assign_and
	| expr_assign_or
	| expr_assign_not
	| expr_assign_left_shift
	| expr_assign_right_shift
	
expr_assign ::= expr '=' expr {rightAssociative=true}
expr_assign_increment ::= expr '+' '=' expr {rightAssociative=true}
expr_assign_decrement ::= expr '-' '=' expr {rightAssociative=true}
expr_assign_multiply ::= expr '*' '=' expr {rightAssociative=true}
expr_assign_divide ::= expr '/' '=' expr {rightAssociative=true}
expr_assign_modulo ::= expr '%' '=' expr {rightAssociative=true}
expr_assign_and ::= expr '&' '=' expr {rightAssociative=true}
expr_assign_or ::= expr '|' '=' expr {rightAssociative=true}
expr_assign_not ::= expr '^' '=' expr {rightAssociative=true}
expr_assign_left_shift ::= expr '<' '<' '=' expr {rightAssociative=true}
expr_assign_right_shift ::= expr '>' '>' '=' expr {rightAssociative=true}

private mul_group ::= expr_multiply | expr_divide | expr_modulo
expr_divide ::= expr '/' expr
expr_multiply ::= expr '*' expr
expr_modulo ::= expr '%' expr

// Private rules to define operators with the same priority
private unary_group ::= expr_unary_plus | expr_unary_minus | expr_unary_not | expr_deref | expr_box | expr_borrow
expr_unary_minus ::= '-' expr
expr_unary_plus ::= '+' expr
expr_unary_not ::= '!' expr
expr_deref ::= '*' expr
expr_box ::= '~' expr
expr_borrow ::= '&' expr

private add_group ::= expr_plus | expr_minus
expr_plus ::= expr '+' expr
expr_minus ::= expr '-' expr

private shift_group ::= expr_left_shift | expr_right_shift
expr_left_shift ::= expr '<' '<' expr
expr_right_shift ::= expr '>' '>' expr

private comparison_group ::= expr_greater_than | expr_less_than | expr_greater_or_equal | expr_less_or_equal
expr_less_or_equal ::= expr '<=' expr
expr_less_than ::= expr '<' !'<' expr
expr_greater_or_equal ::= expr '>=' expr
expr_greater_than ::= expr '>'  !'>' expr

private equals_group ::= expr_equal_to | expr_not_equal_to
expr_not_equal_to ::= expr '!=' expr
expr_equal_to ::= expr '==' expr

expr_logical_and ::= expr '&' '&' expr
expr_logical_or ::= expr '|' '|' expr

private closure_group ::= expr_closure | expr_proc
expr_closure ::= '|' closure_args '|' closure_body
expr_proc ::= 'proc' '(' closure_args ')' closure_body

closure_args ::= [IDENTIFIER [':' type] (',' IDENTIFIER [':' type])*]
closure_body ::= ['->' type] (statement | statement_block)

private primary_group ::= expr_paren | expr_if | expr_struct_initializer | expr_match | expr_path | expr_identifier | expr_value
expr_paren ::= '(' expr expr_tuple_body? ')'
expr_tuple_body ::= ',' [expr (',' expr)*]
expr_field ::= expr '.' IDENTIFIER
expr_value ::= literal
expr_identifier ::= IDENTIFIER
expr_struct_initializer ::= expr '{' struct_initializer_list "}"
struct_initializer_list ::= IDENTIFIER ':' expr (',' IDENTIFIER ':' expr)*

expr_match ::= 'match' expr '{' match_body '}' {pin=1}
match_body ::= match_arm* {recoverWhile="not_close_brace"}
match_arm ::= match_filter ('|' match_filter)* '=>' (statement_block | statement) ','?
match_filter ::= match_pattern match_if?
match_if ::= 'if' expr
match_pattern ::= struct_match_pattern | enum_match_pattern | vector_match_pattern | scalar_match_pattern

enum_match_pattern ::= match_label? type ['(' match_label? enum_match_identifier (',' match_label? enum_match_identifier)* ')']
match_label ::= 'ref'? 'mut'? IDENTIFIER '@'
private enum_match_identifier ::= IDENTIFIER | '.' '.' | enum_match_pattern | literal

vector_match_pattern ::= '[' [vector_match_identifier (',' vector_match_identifier)* ] ']'
private vector_match_identifier ::= IDENTIFIER | ('.' '.' IDENTIFIER? )

struct_match_pattern ::= type '{' struct_match_pattern_argument (',' struct_match_pattern_argument)* [',' '.' '.'] '}'
private struct_match_pattern_argument ::= IDENTIFIER [':' (IDENTIFIER | literal)]

scalar_match_pattern ::= (literal | IDENTIFIER) ['.' '.' (literal | IDENTIFIER)]

expr_call ::= expr '!'? '(' call_params ')'
call_params ::= expr? (',' expr)*

expr_if ::= 'if' expr statement_block if_tail
if_tail ::= ('else' 'if' expr statement_block)* ['else' statement_block]


// Builtin expressions
private builtin_expression_group ::= expr_continue | expr_break
expr_continue ::= 'continue' lifetime?
expr_break ::= 'break' lifetime?

// These constructs don't need a trailing semicolon unless found as part of an expression
expr_block ::= block_for | block_while | block_loop
block_for ::= 'for' expr 'in' expr statement_block
block_while ::= 'while' expr statement_block
block_loop ::= [lifetime ':'] 'loop' statement_block


// TYPES
expr_path ::= '::'? ('self' '::' | 'super' '::')* IDENTIFIER ('::' IDENTIFIER)* ['::' generic]
private type ::= type_basic | type_tuple | type_closure | function_type | type_proc | type_none

type_basic ::= ( ref 'mut'? | lifetime | '*' | 'mut' | '*' 'mut')* ('~' | '@' | '$')? ( type_path | '[' type [',' '.' '.' static_expression] ']' )

type_tuple ::= '(' type (',' type)* ')'
function_type ::= ['extern' STRING_LIT] 'unsafe'? 'fn' trait_bounds? '(' type_closure_args ')' ['->' return_type]
type_closure ::= lifetime? '|' type_closure_args '|' ['->' return_type]
type_proc ::= 'proc' trait_bounds? '(' type_closure_args ')' ['->' return_type]
type_none ::= '*'? '(' ')'
private type_closure_args ::=  [ type_closure_arg ( ',' type_closure_arg)* ]
private type_closure_arg ::= var_name ':' type | type_basic

private type_path ::= '::'? ('self' '::' | 'super' '::')* IDENTIFIER ('::' IDENTIFIER)* generic? trait_bounds?
ref ::= '&'+ lifetime?
lifetime ::= "'" (IDENTIFIER | 'static')


// GENERIC PARAM LIST eg function<A>(...)
generic_params ::= '<' generic_param (',' generic_param)* '>'
private generic_param ::= lifetime | IDENTIFIER (region_bound | [(':' | '=') type ('+' type)* ])
region_bound ::= ':' "'" 'static'

// GENERIC TYPES eg Option<Foo>
generic ::= '<' (generic_without_lifetime | generic_with_lifetime) '>'
private generic_with_lifetime ::= lifetime (',' lifetime)* (',' type)*
private generic_without_lifetime ::= type ( ',' type)*


// USE
use ::= use_internal ';'
private use_internal ::= ['pub'] 'use' (use_glob | use_part ('::' use_part)* ('::' use_glob | '=' expr_path)?) {pin=2 recoverWhile="not_semicolon"}
private use_glob ::= ('*' | '{' IDENTIFIER ( ',' IDENTIFIER )* '}')
private use_part ::= (IDENTIFIER | 'super' | 'self')


// FUNCTIONS
function ::= function_declaration statement_block
function_declaration ::= ['pub'] 'fn' IDENTIFIER generic_params? '(' ( arg (',' arg)* )? ')' ['->' return_type] {pin=2 recoverWhile="function_recover" }
private return_type ::= type | '!'
private function_recover ::= !('{'|';')

private arg ::= self_arg | standard_arg | tuple_arg
standard_arg ::= var_name [':' type ]
tuple_arg ::= '(' var_name (',' var_name)* ')' [':' type ]
self_arg ::= ref? 'mut'? '~'? 'self'
private var_name ::= 'static'? ref? 'mut'? IDENTIFIER

statement_block ::= statement_block_internal '}'
statement_block_internal ::= '{' statement* {pin=1 recoverWhile="not_close_brace"}
private statement ::= statement_block
	| expr_block
	| expr ';'?
	| function
	| use
	| let
	| type_definition
	| struct
	| attribute
	| extern
	| return_statement

return_statement ::= 'return' expr? ';'?

// STRUCTS
struct ::= 'pub'? 'struct' IDENTIFIER generic_params? (struct_body '}' | tuple_body ')' | ';')
struct_body ::= '{' [struct_property (',' struct_property)* ] ','? {pin=1 recoverWhile="not_close_brace"}
tuple_body ::= '(' type (',' type)* {pin=1 recoverWhile="not_close_parenthesis"}
struct_property ::= ['priv' | 'pub'] standard_arg

// TRAITS
trait ::= trait_internal '}'
private trait_internal ::= ['priv' | 'pub'] 'trait' IDENTIFIER generic_params? [':' type ('+' type)*] '{' (attribute | trait_function_declaration (';' | statement_block) )* {pin=2 recoverWhile="not_close_brace"}
trait_function_declaration ::= ['pub'] 'fn' IDENTIFIER generic_params? '(' ( (arg|type) (',' (arg|type))* )? ')' ['->' return_type] {pin=3 recoverWhile="not_semicolon_or_open_brace" }

trait_bounds ::= ':' IDENTIFIER?

// EXTERNALS
extern ::= 'extern' (extern_crate ';' | extern_string '}' | extern_function)
extern_string ::= STRING_LIT? '{' (attribute | standard_arg ';' | trait_function_declaration ';')* {pin=2 recoverWhile="not_close_brace"}
extern_crate ::= 'crate' IDENTIFIER ['=' STRING_LIT] {pin=1 recoverWhile="not_semicolon"}
extern_function ::= function


// LET
let ::= 'let' (type_tuple | let_destructuring | var_name) [':' type] ['=' expr] ';'?
private let_destructuring ::= type '{' IDENTIFIER [':' IDENTIFIER] (',' IDENTIFIER [':' IDENTIFIER] )* [',' '.' '.'] '}'

// ATTRIBUTES
attribute ::= attribute_internal ']'
private attribute_internal ::= '#' '!'? '[' attribute_list {pin=1 recoverWhile="attrib_recover"}
private attribute_list ::= attribute_arg ( ',' attribute_arg )*
attribute_arg ::= IDENTIFIER [ '=' literal | '(' attribute_list ')' ]
private attrib_recover ::= !(']' | ';')


// TYPE
type_definition ::= 'type' IDENTIFIER '=' type ';'

private token ::= (simple_token|literal|comment|symbol|brackets|operators|keyword|IDENTIFIER)
private keyword ::= (KW_AS|KW_BREAK|KW_CRATE|KW_ELSE|KW_LET|KW_STRUCT|KW_ENUM|KW_FALSE|KW_FOR|KW_IF|KW_IMPL|KW_IN|KW_LOOP|KW_MATCH|KW_MOD|KW_MUT|KW_PRIV|KW_PROC|KW_PUB|KW_REF|KW_RETURN|KW_SELF|KW_STATIC|KW_SUPER|KW_TRUE|KW_TYPE|KW_UNSAFE|KW_WHILE)
private simple_token ::= (UNOP|BINOP)
private comment ::= (BLOCK_COMMENT|BLOCK_DOC_COMMENT|LINE_COMMENT|LINE_DOC_COMMENT)
private brackets ::= (OPEN_SQUARE_BRACKET|CLOSE_SQUARE_BRACKET|OPEN_PAREN|CLOSE_PAREN|OPEN_BRACE|CLOSE_BRACE)
private symbol ::= (HASH|COMMA|SEMICOLON|DOUBLE_COLON|THIN_ARROW|FAT_ARROW|DOT|AT|SINGLE_QUOTE|DOLLAR|':')
private operators ::= (arithmetic_operators|bitwise_operators|comparison_operators|unary_operators|AS|ASSIGN)
private arithmetic_operators ::= (PLUS|MINUS|MULTIPLY|DIVIDE|REMAINDER)
private bitwise_operators ::= (BITWISE_AND|BITWISE_OR|BITWISE_XOR)
private unary_operators ::= (NOT|BOX)
private comparison_operators ::= (EQUAL|GREATER_THAN|LESS_THAN|NOT_EQUAL|GREATER_THAN_OR_EQUAL|LESS_THAN_OR_EQUAL)
